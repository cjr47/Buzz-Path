{"ast":null,"code":"var _jsxFileName = \"/Users/micahberman/Documents/momentum/buzzpath/src/components/map.js\",\n    _s = $RefreshSig$();\n\nimport { useLoadScript, GoogleMap, Autocomplete, DirectionsRenderer, Marker, directions, google, results, originRef, destinationRef, setDirectionsResponse, setDistance, setDuration, distance, duration, coffeeDistance, directionsResponse, getMarkers, route, map } from \"@react-google-maps/api\";\nimport React, { useState, useRef } from 'react';\nimport \"./maps.css\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst center = {\n  lat: 35.9940,\n  lng: -78.8986\n};\nconst libraries = [\"places\"];\nconst mapContainerStyle = {\n  width: \"100%\",\n  height: \"100%\",\n  overflow: \"visible\",\n  resetBoundsOnResize: \"true\"\n};\nexport default function Gmap(_ref) {\n  _s();\n\n  let {\n    rangeValue\n  } = _ref;\n  const [map, setMap] = useState(null);\n  const [directionsResponse, setDirectionsResponse] = useState(null);\n  const [distance, setDistance] = useState(\"\");\n  const [duration, setDuration] = useState(\"\");\n  const originRef = useRef();\n  const destinationRef = useRef();\n  const {\n    isLoaded,\n    loaderror\n  } = useLoadScript({\n    googleMapsApiKey: process.env.REACT_APP_GOOGLE_MAPS_API_KEY,\n    libraries\n  });\n  if (loaderror) return \"Where's my Coffee!! - be\";\n  if (!isLoaded) return \"Finding your coffee\";\n  const distCoffee = distance.slice(0, -2);\n  const intCoffee = Number(distCoffee);\n  console.log(rangeValue);\n  /* async function coffeeStops({rangeValue}) { */\n\n  const coffeeDistance = intCoffee / rangeValue;\n  /*   await calculatePath;\n    if (distance > 0) {\n      console.log(coffeeDistance)\n      return coffeeDistance;\n      console.log({distance}); */\n\n  /* Micah's Code */\n\n  const directions = {};\n  const stops = 2;\n  const route = setDirectionsResponse(results);\n  route.rendering.routeId = `thisRoute`; // Set the stops for the route to the first value (default)\n\n  route.rendering.stops = stops; // When this select element is changed, update the route renderer.stops to the new value\n  // update the route renderer.stops to the new value\n\n  directions[this.name].renderer.stops = this.value; // Draw the new markers for the route that just had it's stops changed\n\n  setMarkers(this.name);\n}\n\n_s(Gmap, \"FqN0uWkpgi9vCILvTx3USBdz/XM=\", false, function () {\n  return [useLoadScript];\n});\n\n_c = Gmap;\n;\nrequestRoute(route, map); // Set markers for the route with ID\n\nconst setMarkers = ID => {\n  // Get info about the route\n  const direction = directions[ID],\n        renderer = direction.renderer,\n        stop = renderer.stops,\n        marker = renderer.marker,\n        map = renderer.getMap(),\n        dirs = direction.renderer.getDirections();\n  marker.map = map; // For each set, which is an object where key: number of stops and value: list of markers\n\n  for (const k in direction.sets) {\n    const set = directions[ID].sets[k]; // Only show the set of markers that match the currently selected number of stops\n\n    set.visible = !!(k === stop); // For each marker in the set\n\n    set.forEach(marker => {\n      // If this is the visible set, set the marker map to the map otherwise null\n      marker.setMap(set.visible ? map : null);\n    });\n  }\n\n  ; // If a set of markers has not been calculated for this number of stops yet\n\n  if (!direction.sets[stop]) {\n    if (dirs.routes.length) {\n      const route = dirs.routes[0];\n      let distanceBetweenStops = 0; // For each leg in the route\n\n      route.legs.forEach(leg => {\n        if (leg.distance) {\n          // Set the distance between stops to (total leg distance) / (number of stops + 1)\n          distanceBetweenStops = leg.distance.value / (parseInt(stop) + 1);\n        }\n      }); // Get the list of markers for this milestone\n\n      direction.sets[stop] = getMarkers(route, distanceBetweenStops, marker);\n    }\n  }\n}; // Remove old markers and render updated map with markers\n\n\nconst requestRoute = (route, map) => {\n  if (!window.gDirSVC) window.gDirSVC = new google.maps.DirectionsService();\n  var renderer = new google.maps.DirectionsRenderer(route.rendering);\n  var renderer = new google.maps.DirectionsRenderer(route.rendering);\n  renderer.setMap(map);\n  renderer.setOptions({\n    preserveViewport: true\n  });\n  google.maps.event.addListener(renderer, 'directions_changed', function () {\n    if (directions[this.routeId]) {\n      //remove markers\n      for (var k in directions[this.routeId].sets) {\n        for (var m = 0; m < directions[this.routeId].sets[k].length; ++m) {\n          directions[this.routeId].sets[k][m].setMap(null);\n        }\n      }\n    }\n\n    directions[this.routeId] = {\n      renderer: this,\n      sets: {}\n    };\n    setMarkers(this.routeId);\n  });\n  window.gDirSVC.route(route.request, function (response, status) {\n    if (status == google.maps.DirectionsStatus.OK) {\n      renderer.setDirections(response);\n    }\n  });\n  /*Micah's Code*/\n\n  async function calculatePath() {\n    if (originRef.current.value === '' || destinationRef.current.value === '') {\n      return;\n    } // eslint-disable-next-line no-undef\n\n\n    const directionsService = new google.maps.DirectionsService();\n    const results = await directionsService.route({\n      origin: originRef.current.value,\n      destination: destinationRef.current.value,\n      // eslint-disable-next-line no-undef\n      travelMode: google.maps.TravelMode.DRIVING\n    });\n    setDirectionsResponse(results);\n    setDistance(results.routes[0].legs[0].distance.text);\n    setDuration(results.routes[0].legs[0].duration.text);\n    /* console.log(coffeeDistance) */\n  }\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      children: /*#__PURE__*/_jsxDEV(Autocomplete, {\n        children: /*#__PURE__*/_jsxDEV(\"input\", {\n          type: \"text\",\n          placeholder: \"Origin\",\n          ref: originRef\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 210,\n          columnNumber: 9\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 209,\n        columnNumber: 7\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 208,\n      columnNumber: 5\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      children: /*#__PURE__*/_jsxDEV(Autocomplete, {\n        children: /*#__PURE__*/_jsxDEV(\"input\", {\n          type: \"text\",\n          placeholder: \"Destination\",\n          ref: destinationRef\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 215,\n          columnNumber: 9\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 214,\n        columnNumber: 7\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 213,\n      columnNumber: 5\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      children: /*#__PURE__*/_jsxDEV(\"button\", {\n        type: \"submit\",\n        onClick: calculatePath,\n        children: \"Find your Buzzed Path\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 220,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 219,\n      columnNumber: 5\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        children: [\"Distance: \", distance]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 223,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [\"Duration: \", duration]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 225,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [\"Miles per Coffee: \", coffeeDistance]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 226,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 222,\n      columnNumber: 5\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"coffeemap\",\n      children: /*#__PURE__*/_jsxDEV(GoogleMap, {\n        mapContainerStyle: mapContainerStyle,\n        zoom: 8,\n        center: center,\n        children: [/*#__PURE__*/_jsxDEV(Marker, {\n          position: center\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 235,\n          columnNumber: 8\n        }, this), directionsResponse && /*#__PURE__*/_jsxDEV(DirectionsRenderer, {\n          directions: directionsResponse\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 237,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 231,\n        columnNumber: 7\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 230,\n      columnNumber: 5\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 207,\n    columnNumber: 3\n  }, this);\n};\n\nvar _c;\n\n$RefreshReg$(_c, \"Gmap\");","map":{"version":3,"sources":["/Users/micahberman/Documents/momentum/buzzpath/src/components/map.js"],"names":["useLoadScript","GoogleMap","Autocomplete","DirectionsRenderer","Marker","directions","google","results","originRef","destinationRef","setDirectionsResponse","setDistance","setDuration","distance","duration","coffeeDistance","directionsResponse","getMarkers","route","map","React","useState","useRef","center","lat","lng","libraries","mapContainerStyle","width","height","overflow","resetBoundsOnResize","Gmap","rangeValue","setMap","isLoaded","loaderror","googleMapsApiKey","process","env","REACT_APP_GOOGLE_MAPS_API_KEY","distCoffee","slice","intCoffee","Number","console","log","stops","rendering","routeId","name","renderer","value","setMarkers","requestRoute","ID","direction","stop","marker","getMap","dirs","getDirections","k","sets","set","visible","forEach","routes","length","distanceBetweenStops","legs","leg","parseInt","window","gDirSVC","maps","DirectionsService","setOptions","preserveViewport","event","addListener","m","request","response","status","DirectionsStatus","OK","setDirections","calculatePath","current","directionsService","origin","destination","travelMode","TravelMode","DRIVING","text"],"mappings":"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","sourcesContent":["import {\n  useLoadScript,\n  GoogleMap,\n  Autocomplete,\n  DirectionsRenderer,\n  Marker,\n  directions,\n  google,\n  results,\n  originRef,\n  destinationRef,\n  setDirectionsResponse,\n  setDistance,\n  setDuration,\n  distance,\n  duration,\n  coffeeDistance,\n  directionsResponse,\n  getMarkers,\n  route,\n  map,\n} from \"@react-google-maps/api\";\nimport React, { useState, useRef } from 'react'\nimport \"./maps.css\"\n\n \n\n\n\nconst center = {lat: 35.9940,lng: -78.8986}\nconst libraries = [\"places\"]\nconst mapContainerStyle = {\n    width: \"100%\",\n    height: \"100%\",\n    overflow: \"visible\",\n    resetBoundsOnResize: \"true\",\n}\n\n\nexport default function Gmap ({rangeValue}) {\n    \n                const [map, setMap] = useState(null);\n                const [directionsResponse, setDirectionsResponse] =\n                  useState(null);\n                const [distance, setDistance] = useState(\"\");\n                const [duration, setDuration] = useState(\"\");\n                \n                \n                const originRef = useRef();\n                const destinationRef = useRef();\n    const { isLoaded, loaderror } = useLoadScript({\n          googleMapsApiKey: process.env.REACT_APP_GOOGLE_MAPS_API_KEY,\n          libraries,\n        });\n    if (loaderror) return \"Where's my Coffee!! - be\";\n    if(!isLoaded) return \"Finding your coffee\";\n\n\n    const distCoffee = (distance.slice(0,-2))\n    const intCoffee = Number(distCoffee)\n       console.log(rangeValue)     \n\n   \n   \n /* async function coffeeStops({rangeValue}) { */\n           const coffeeDistance = intCoffee /(rangeValue); \n\n        /*   await calculatePath;\n          if (distance > 0) {\n            console.log(coffeeDistance)\n            return coffeeDistance;\n            console.log({distance}); */\n\n\n/* Micah's Code */\n      const directions = {};     \n      const stops = 2;\n      const route = setDirectionsResponse(results)  \n\n      route.rendering.routeId = `thisRoute`;\n      // Set the stops for the route to the first value (default)\n      route.rendering.stops = stops;\n      // When this select element is changed, update the route renderer.stops to the new value\n      \n        // update the route renderer.stops to the new value\n        directions[this.name].renderer.stops = this.value;\n        // Draw the new markers for the route that just had it's stops changed\n        setMarkers(this.name)\n      };         \n      requestRoute(route,map);\n    \n  \n  \n  // Set markers for the route with ID\n  const setMarkers = (ID) => {\n    // Get info about the route\n    const direction = directions[ID],\n        renderer = direction.renderer,\n        stop = renderer.stops,\n        marker = renderer.marker,\n        map = renderer.getMap(),\n        dirs = direction.renderer.getDirections();\n        marker.map = map;\n\n    // For each set, which is an object where key: number of stops and value: list of markers\n    for (const k in direction.sets) {\n      const set = directions[ID].sets[k];\n      // Only show the set of markers that match the currently selected number of stops\n      set.visible = !!(k === stop);\n      \n      // For each marker in the set\n      set.forEach(marker => {\n        // If this is the visible set, set the marker map to the map otherwise null\n        marker.setMap(set.visible ? map : null);\n      });\n    };\n\n    // If a set of markers has not been calculated for this number of stops yet\n    if(!direction.sets[stop]) {\n      if(dirs.routes.length) {\n        const route = dirs.routes[0];\n        let distanceBetweenStops = 0;\n\n        // For each leg in the route\n        route.legs.forEach(leg => {\n          if(leg.distance) {\n            // Set the distance between stops to (total leg distance) / (number of stops + 1)\n            distanceBetweenStops = leg.distance.value / (parseInt(stop) + 1);\n          }\n          \n        });\n        \n        // Get the list of markers for this milestone\n        direction.sets[stop]= getMarkers(route, distanceBetweenStops, marker);\n      }\n    }\n  }\n  \n  // Remove old markers and render updated map with markers\n   const requestRoute = (route,map) => {\n    if(!window.gDirSVC) window.gDirSVC = new google.maps.DirectionsService();\n        \n    var renderer=new google.maps.DirectionsRenderer(route.rendering);\n     var renderer=new google.maps.DirectionsRenderer(route.rendering);\n        renderer.setMap(map);\n        renderer.setOptions({preserveViewport:true})\n        \n    \n    google.maps.event.addListener(renderer, 'directions_changed', function() {\n          \n          if(directions[this.routeId])\n          {\n           //remove markers\n            for(var k in directions[this.routeId].sets)\n            {              \n                for(var m=0;m<directions[this.routeId].sets[k].length;++m)\n                {\n                  directions[this.routeId].sets[k][m].setMap(null);\n                }\n            }\n          }\n\n          directions[this.routeId]={renderer:this,sets:{}};\n          setMarkers(this.routeId);\n          \n    });\n\n     window.gDirSVC.route(route.request, function(response, status) {\n      if (status == google.maps.DirectionsStatus.OK) {\n        renderer.setDirections(response);\n    }\n    });\n   \n \n      \n/*Micah's Code*/ \n          \n    async function calculatePath(){\n       \n        if (originRef.current.value === '' || destinationRef.current.value === ''){\n            return\n        }\n        \n        // eslint-disable-next-line no-undef\n        const directionsService = new google.maps.DirectionsService()\n        const results = await directionsService.route({\n          origin: originRef.current.value,\n          destination: destinationRef.current.value,\n          // eslint-disable-next-line no-undef\n          travelMode: google.maps.TravelMode.DRIVING,\n        \n        });\n            \n        setDirectionsResponse(results)\n        setDistance(results.routes[0].legs[0].distance.text)\n        setDuration(results.routes[0].legs[0].duration.text)\n        \n        /* console.log(coffeeDistance) */\n        \n        \n\n    }\n\n\n\nreturn (\n  <div>\n    <div>\n      <Autocomplete>\n        <input type=\"text\" placeholder=\"Origin\" ref={originRef} />\n      </Autocomplete>\n    </div>\n    <div>\n      <Autocomplete>\n        <input type=\"text\" placeholder=\"Destination\" ref={destinationRef} />\n      </Autocomplete>\n    </div>\n    \n    <div>\n        <button type='submit' onClick={calculatePath}>Find your Buzzed Path</button>\n    </div>\n    <div>\n        <p>Distance: {distance}</p>\n        \n        <p>Duration: {duration}</p>\n        <p>Miles per Coffee: {coffeeDistance}</p>\n{/*         <p>Miles per Coffee: {intCoffee/rangeValue}</p>\n */}        \n    </div>\n    <div className=\"coffeemap\">\n      <GoogleMap\n        mapContainerStyle={mapContainerStyle}\n        zoom={8}\n        center={center}\n      ><Marker position={center}/>\n        {directionsResponse && (\n            <DirectionsRenderer directions = {directionsResponse}/>\n        )}</GoogleMap>\n    </div>\n  </div>\n);\n}\n"]},"metadata":{},"sourceType":"module"}